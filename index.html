<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Racetrack with 4 ArUco Markers â€“ Continuous Update</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <!-- Include AR.js for AR functionality -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
      .a-enter-vr,
      .a-enter-ar {
        position: fixed !important;
        bottom: 20px !important;
        transform: translateX(-50%) !important;
      }
      .a-enter-vr {
        left: 50% !important;
      }
      .a-enter-ar {
        left: 35% !important;
      }
    </style>
  </head>
  <body>
    <a-scene embedded arjs>
      <a-assets>
        <a-asset-item id="track" src="racing_track.gltf"></a-asset-item>
      </a-assets>

      <!-- Lighting -->
      <a-light type="ambient" intensity="0.5"></a-light>
      <a-light type="directional" position="2 5 3" intensity="0.8"></a-light>

      <!-- Four markers (one per corner of the box) -->
      <a-marker
        preset="custom"
        type="pattern"
        url="markers/marker1.patt"
        id="marker1"
      ></a-marker>
      <a-marker
        preset="custom"
        type="pattern"
        url="markers/marker2.patt"
        id="marker2"
      ></a-marker>
      <a-marker
        preset="custom"
        type="pattern"
        url="markers/marker3.patt"
        id="marker3"
      ></a-marker>
      <a-marker
        preset="custom"
        type="pattern"
        url="markers/marker4.patt"
        id="marker4"
      ></a-marker>

      <!-- Parent entity for the AR asset. The custom component 'update-anchor'
           will update its position/rotation every frame based on the markers. -->
      <a-entity id="boxAnchor" update-anchor>
        <a-entity
          id="arAsset"
          gltf-model="#track"
          position="0 0.05 -1.5"
          rotation="0 90 0"
          scale="0.5 0.5 0.5"
        ></a-entity>
      </a-entity>

      <!-- Camera with a cursor -->
      <a-entity camera>
        <a-cursor></a-cursor>
      </a-entity>
    </a-scene>

    <script>
      // Optional: Style AR entry button when DOM is loaded.
      document.addEventListener("DOMContentLoaded", function () {
        let arButton = document.querySelector(".a-enter-vr");
        if (arButton) {
          arButton.classList.add("a-enter-ar");
        }
      });

      // Scale adjustments when entering/exiting AR mode.
      document
        .querySelector("a-scene")
        .addEventListener("enter-ar", function () {
          if (AFRAME.utils.device.isARCapable()) {
            document
              .querySelector("#arAsset")
              .setAttribute("scale", "0.3 0.3 0.3");
          }
        });
      document
        .querySelector("a-scene")
        .addEventListener("exit-ar", function () {
          document.querySelector("#arAsset").setAttribute("scale", "1 1 1");
        });

      // Register a component that updates the boxAnchor every frame.
      AFRAME.registerComponent("update-anchor", {
        tick: function () {
          // Get all markers.
          const markers = document.querySelectorAll("a-marker");
          const visibleMarkers = [];

          markers.forEach((marker) => {
            // Use marker.object3D.visible as a basic check.
            if (marker.object3D.visible) {
              visibleMarkers.push(marker);
            }
          });

          if (visibleMarkers.length === 0) return; // No markers detected.

          // Initialize averaging containers.
          let avgPosition = new THREE.Vector3();
          let avgQuaternion = new THREE.Quaternion();
          let count = 0;

          visibleMarkers.forEach((marker, idx) => {
            const obj = marker.object3D;
            // Ensure the matrixWorld is updated.
            obj.updateMatrixWorld();
            const pos = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            obj.matrixWorld.decompose(pos, quat, scale);

            avgPosition.add(pos);
            if (count === 0) {
              avgQuaternion.copy(quat);
            } else {
              // Slerp blend with current quaternion for smoother averaging.
              avgQuaternion.slerp(quat, 1 / (count + 1));
            }
            count++;
          });

          avgPosition.multiplyScalar(1 / count);

          // Update the anchor entity's transformation.
          this.el.object3D.position.copy(avgPosition);
          this.el.object3D.quaternion.copy(avgQuaternion);
        },
      });
    </script>
  </body>
</html>